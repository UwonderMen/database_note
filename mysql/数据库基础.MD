
#数据库介绍
```
  数据库：按照数据结构来组织、存储、管理数据的仓库
```

##mysql数据库MyISAM和InnoDB存储引擎区别
```
  MyISAM存储引擎不支持事务，插入和查询非常快
  InnoDB存储引擎支持事务，锁的粒度达到了行级锁，mysql5.5后InnoDB是默认的存储引擎
```

#SQL语句分类
```
  1、DDL数据定义语言：负责数据库的定义，数据库对象定义，有create、alter、drop是三个语句组成
  2、DML数据操作语言，负责对数据库对象的操作，包括CRUD增删改查
  3、DCL数据控制语言，负责数据库权限访问的控制，由grant和revoke两个命令组成
  4、TCL事务控制语言，负责处理ACID事务，支持commit和rollback指令

  注意：SQL语句大小写不敏感，sql语句末尾应该有结束符号分号(;)
```

##DML
  1、insert语句
    ```
      insert into 表名(字段,字段2....) values(值,值1....)
      向表中插入一行数据，自增字段、缺省值字段、可为空字段可以不写

      insert into 表名2  select 字段[...] from 表名1
      将select表名1中查询的数据插入到表名2中

      insert into 表名(字段名,字段名2....) values(值,值2...) on duplicate update 字段名=值.....
      如果主键冲突，唯一键冲突就执行update后边的设置，这条语句的意思就是主键不在就新增这条记录，主键在就更新其中的部分字段

      insert ignore into 表名(字段,字段2....)  values(值,值1..)
      如果主键冲突，唯一键冲突就忽略错误，返回一个警告
    ```

  2、update语句
    ```
      update [ignore] 表名 set 字段名=值...... where 条件
      ignore：表示如果错误就忽略错误，不会插入成功，返回一个警告
    ```

  3、delete语句
    ```
      delete [ignore]  表名 where 条件
      删除符合条件的记录或者行
    ```

  4、select语句
    ```

    ```

##DCL
  1、grant授权命令
    -- grant  授权命令  on 数据库.表 to 用户@主机  identified by 密码;

  2、revoke撤销命令
    -- revoke 撤销的命令  on  库.表 from 用户

  3、删除用户（慎用）
    -- drop user 用户;

##DDL
  ####create database 数据库名   ->创建数据库
  1、create database if exists 数据库名 character set 字符集 collate 字符校验规则
    ````
      character set 指定字符集
      注意：utf8mb4是utf8的宽展支持4个字节utf8mb4，但是需要mysql5.5.3+

      collate  指定字符集的校对规则，用来做字符串比较，比如：a和A谁大
    ```

  2、drop database 数据库名  -->删除数据库
    ```
        书写良好的话要做个判断，如果存在数据库，就删除数据库
        drop database if exists 数据库名
    ```

##DDL
  1、 create table 表名(字段1，字段2...)  --->创建表
    注意：
      1、列名一般使用反引号包裹起来
      2、定义规则：
        *列名  类型  约束*
      3、在创建表时还可以指定引擎和字符集
        *
          create table 表名(
            字段1，
            字段2...
          )engine=(InnoDB|myISAM) default charset=charset
        *
  2、查看列或者表的定义
    {describe|DESC}  表名[列名]

    例子：
    root@localhost project 06:08:03>desc class;
      +--------+------------+------+-----+---------+----------------+
      | Field  | Type       | Null | Key | Default | Extra          |
      +--------+------------+------+-----+---------+----------------+
      | id     | int(11)    | NO   | PRI | NULL    | auto_increment |
      | cid    | int(10)    | NO   | MUL | NULL    |                |
      | tid    | bigint(10) | NO   | MUL | NULL    |                |
      | sid    | bigint(10) | NO   | MUL | NULL    |                |
      | time   | int(11)    | YES  | MUL | NULL    |                |
      | addrid | int(4)     | NO   | MUL | NULL    |                |
      | weekid | int(4)     | NO   | MUL | NULL    |                |
      | timeid | int(4)     | NO   | MUL | NULL    |                |
      | mid    | int(4)     | NO   | MUL | NULL    |                |
      +--------+------------+------+-----+---------+----------------+
    3、primary key主键
        ```
          表中的一列或者多列组成唯一的key，也就是通过这一个或者多个能唯一标识的一条记录，主键的列不能为空，主键往往为整形，长整形，且自增auto_increatement，表中可以没有主键，但是，一般表设计中都会有主键
        ```
        例子：
         create table bt(
           id int primary key not null
           name char(10) not null
           )
      4、索引index
        ```
          ***合理的设置索引能够极大的提升数据库的查询效率，但是不能够过度建立索引***

          1、可以看做是一本大字典的目录，为了快速检索用。这是一种空间换时间，显著提升查询效率
          2、索引可以对一列或者多列设定索引
            主键索引：主键自动建立主键索引，主键本身就是为了快速定位为记录，主键索引不允许为null，且不允许重复
            唯一索引：表中的索引列组成的索引必须唯一，但是可以为空，非空值必须唯一
            普通索引：没有唯一性要求，就是见了一个字典的目录而已

        ```

      5、约束constraint
        ```
          unique约束（唯一约束）：定义了唯一键索引，就定义了唯一键的约束
          primary key外键约束：定义了主键，就定义了主键约束
        ```

      6、外键约束 foreign key
        ```
          外键，在表b中的列，关联表A中的主键，表b中的列就是外键
          1、如果在表b中插入一条数据，b表的外键列插入一个值，这个值必须是表A中存在的主键，修改表b的外键值也是同样，外键值同样要在表A中存在
          2、如果表A中要删除一条数据，那么就等于删除一个主键，那么如果表b中引用到了这个主键，那么需要先删除b中引用的这个主键记录，然后在删除表A的记录，否则删除失败
          3、修改表A的主键，由于主键的唯一性，修改主键相当于插入新的主键，那么如果表b引用到这个主键，将阻止表A的主键修改，必须删除表b的相关记录后，才可以修改表A的主键，外键约束是为了保证数据完整性，一致性，杜绝数据冗余，以及数据讹误

          注意：外键也有性能影响，外键删除
        ```

      7、视图view
        ```
            数据库中的视图其实就是一个虚表，看起来像表，他是有查询语句生成的，可以通过视图进行CRUD操作

            视图的作用：简化操作，将复杂的查询sql语句定义为视图，可以简化查询
            数据安全性：视图可以只显示真实表的部分列，或者计算后的结果，隐藏真实表的数据

            注意：建议使用视图用来查询
        ```

#mysql数据库的数据类型
  ```
    1、tinyint
      *
        一个字节的大小，带符号的范围是-128-127，无符号的范围是255。bool或者boolean就是tinyint，0表示真，1表示假
      *
    2、smallint
      *
        2个字节，带符号的范围是-23768到32767。无符号范围是65535
      *
    3、int
        *
        存放整形，一般是2个字节，同integer。带符号-2**16-2**16-1，无符号表示范围2**32
      *
    4、bigint
      *
        长整形，一般使用8个字节表示。带符号范围是-2**32-2**32-1,无符号的范围是2**64
      *
    8、float
      *
        单精度浮点书精确到大约7位小数
      *
    9、double
      *
        双精度浮点数精确到大约15位小数
      *
    10、date
      *
        日期，支持范围是1000-01-01~9999012-31 23:59:59
      *
    11、datetime
      *
        支持范围是1000-01-01 00:00:00 到9999-12-31 23:59:59
      *
    12、timestamp
      *
        时间戳，范围是1970-01-01 00:00:00到2037年
      *
    13、char（M）
      *
        固定长度，如果给定字符长度没有达到，右边填充空格已达到长度要求，M表示长度，范围是0-255，注意，M指的是字符个数
      *
    14、varchar(M)
      *
        边长字符串，M表示最大的列长度，M的范围是0-2**16，但是不能突破自大的字节数2**16
      *
    15、text
      *
        大文本，最大长度为2**16-1个字符
      *
    16、blob
      *
        大字节，最大长度为2**16字节的blob列
      *
  ```

  ***关于mysql的length()函数，length函数返回的是字节数，而char和varchar定义的M是字符数的限制***

  ***char可以将字符串变成等长的，空间换时间，效率略高varchar边长，省空间
  ***

  ***
  将全局的外键约束关掉的命令
    set foreign_key_checks = 0
  ***

------------------------------
#关系操作：
  ```
    1、什么是关系：
      在关系性数据库中，关系就是二维表
    2、关系操作就是对表的操作
      **
        选择：又称为限制，是从关系中选择出满足给定条件的元祖
        投影：在关系上投影就是从选择出若干属性列组成新的关系
        连接：将不同的两个关系连接成一个关系
      **
  ```

#子查询
```
  1、查询语句可以嵌套，内部查询就是子查询
  2、子查询必须在一组小括号中
  3、子查询不能使用order by
```

#连接
```
  连接使用的是join
  交叉连接使用的是cross join
  笛卡尔乘积，全部交叉
  在mysql中，cross join 从语法上说与inner join等同
```


#如果两个表连接，要去一个表中的所有，那么可以使用  表.*
```
  a表和b表相连接，取a表的所有列
  select a.* from a inner join b;
```

#等值连接
```
  等值连接：当使用连接时，只选择某些相等的行。等值连接符号on
```

#自然连接
```
  自然连接：特殊的等值连接，在输出时会去掉重复的列。这个用的比较少

```


#内连接(inner join 或者join)
```
  select * from a inner join b;
  简写：
  select * from a join b
```

#自然连接 (nature join)
```
  select * from a nature join b
```

#外连接
```
  外连接使用的是：outer join(可省略outer)
  外连接分类:
    左外链接：又称为左连接  left join
    右外连接：又称为右连接  right join

  注意：
    如果在查询时省略left或者right，那么mysql将按照大表为主表去和另一个表左连接，这主要是为了减少匹配次数
```

#在进行两个表的连接时，有主表和副表之分
```
  1、当时左连接时，即a  left join  b ,此时a表为主表，b表为副表，那么数据的多少以a表为主，如果b表中没有与a表相对应的，那么b表的数据行保留下来，且为空
  2、当时右连接时，即a  right join  b ,此时b表为主表，a表为副表，那么数据的多少以b表为主，如果a表中没有与b表相对应的，那么a表的数据行保留下来
```


#自连接
```
  自连接：单个表左连接，即自己跟自己连接,一般使用inner join
  注意:
    如果确定使用自连接，那么必须跟表取别名
```

------------------------------------------

#事务(Transaction)
```
  InnoDB存储引起支持事务，而myISAM不支持事务
  事务:由多个若干条语句组成，指的是要做的一系列操作,这一些列的操作就是事务


  关系性数据库中支持的事务，必须支持其四个属性(ACID)
    A(原子性automicity)：一个事务是一个不可分割的工作单位，事务中包括的所有操作要么全部做完，要么什么都没做

    C(一致性consistency)：事务必须是使用数据库从一个一致性状态变成另一个一致性状态，一致性与原子性密切相关

    I(隔离性isolaton)：一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰

    D(持久性durability)：持久性也称为永久性，指一个事务一旦提交，他对数据库的改变就应该是永久的，接下来的其他操作或者故障不应该对其有任何影响




    注意：一个事务务必保证：原子性、一致性、持久性
```

#mysql中的隔离
```
  首先看隔离性好不好带来的问题：
    1、更新丢失
      事务a和事务b，更新同一个数据，它们都读取了初始值为100，a事务要减10，b事务要加100，a减去10后，更新为了90，但是b加了100后，更新为了200，此时a更新的数据丢失
    2、脏读
      事务a和事务b，事务b读取到了事务a未提交的数据（这个数据可能就是一个中间值，也可能是事务a后来回滚事务的值）。事务a是否最后提交并不关心，只要读取到这个被修改的数据就是脏读
    3、不可重复读
      事务a在事务执行中相同查询语句，得到了不同的结果，不能保证同一条查询语句重复读取相同的结果就是不可重复读（意思就是在查询过程中有人在修改）
        举例：
          事务a查询一次后，事务b修改了数据，事务a有查询了一次，发现数据不一致了

      注意：脏读是可以读取到相同的数据，但是读取的是一个未提交的数据，不是提交的最终结果
    4、幻读
      事务a中同一个查询要进行多次，而此时事务b插入了数据，那么事务a返回了不同的结果集，就如同幻觉一样，这就是幻读
      即:数据集有记录增加了，可以看做是增加了记录的不可重复读

```

#为了解决隔离性，mysql定义了事务的隔离级别
```
  看图
```

#怎么设置会话即或者全局隔离级别呢？
```
  set [session|global] transaction isolation level {read uncommitted|read committed|repeatable read|serializable}

  距举例：
    set session transaction isolation level read committed;
    set session transaction isolation level repeatable read;

    注意：全局隔离尽量少的设置，要设置都设置会话级别的隔离

```

#查看隔离级别
```
  查看全局隔离级别：select @@global.txisolation;
  查看会话隔离级别：select @@tx.isolation

```

#mysql隔离级别的解释：
```
  1、mysql隔离级别serializable串行了，解决了所有问题
  2、mysql隔离级别repeatable read(可以重复读：用来解决不可重复读)，事务a中同一条查询语句返回同样的结果，就是可以重复读数据了，例如语句select * from user。解决的办法有：
    1、对select的数据加锁，不允许其他事务删除或者修改操作
    2、第一次select的时候，对最后一次确切提交的事务的结果做快照
    这两种方法可以解决不可重复读，但是有可能出现幻读。

  3、read committed，在事务中，每次select可以读取到别的事务刚提交的新数据，因为读到的是提交后的数据，解决了脏读，但是不能解决不可重复读

  4、read uncommitted，能读取到别的事务还未提交的数据，完全没有隔离科研，出现脏读
```

#事务的语法
```
    start transaction或者begin表示开启一个事务。start transaction是标准的sql语法

    使用commit提交事务后，变更成为永久变更，即完成了事务的永久性

    rollback可以在提交事务之前，回滚变更，事务中的操作就如同没有发生过一样

    set autocommit语句可以禁用或者启用默认的autocommit模式，用于当前的连接。set autocommit=0表示禁用自动提交事务，如果开启自动提交，如果有一个修改表的语句执行后，会立即把更新存储到磁盘
```

--------------------------------------------
#游标
```
  操作查询的结果集的一种方法
  可以将游标当做一个指针，指向结果集中的某一行
```

----------------------------------------
#存储过程
```
  存储过程，数据库中一段完成特定功能的sql语句，编写成类似函数的方式，可以传参并调用，支持流程控制
```

---------------------------------------
#触发器
```
  触发器由事件触发的特殊的存储过程，例如insert数据时触发，触发器功能虽然非常强大，但是有性能问题
```
